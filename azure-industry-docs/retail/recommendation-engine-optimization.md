---
title: 권장 엔진 최적화
author: kbaroni
ms.author: kbaroni
ms.date: 07/18/2018
ms.topic: article
ms.service: industry
description: R 언어로 작성된 권장 앱을 다시 사용하고 최적화하는 방법입니다. Azure VM에서 Machine Learning Server를 사용합니다.
ms.openlocfilehash: bce6d7df548e7bd80d73495dc0bec642817d8641
ms.sourcegitcommit: 76f2862adbec59311b5888e043a120f89dc862af
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/03/2018
ms.locfileid: "51654260"
---
# <a name="optimize-and-reuse-an-existing-recommendation-system"></a><span data-ttu-id="d49a6-104">기존 권장 시스템 최적화 및 재사용</span><span class="sxs-lookup"><span data-stu-id="d49a6-104">Optimize and reuse an existing recommendation system</span></span>  

<span data-ttu-id="d49a6-105">이 문서에서는 R로 작성된 기존 권장 시스템을 성공적으로 다시 사용하고 향상시키는 프로세스를 설명합니다. 이에 대한 핵심은 Microsoft Machine Learning Server에 기본적으로 제공된 MicrosoftML 및 RevoScaleR 라이브러리의 병렬 처리입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-105">This document describes the process of successfully reusing and improving an existing recommendation system written in R. The key to this was the parallelism of the MicrosoftML and RevoScaleR libraries built into Microsoft Machine Learning Server.</span></span>

## <a name="recommendation-systems-and-r"></a><span data-ttu-id="d49a6-106">권장 시스템 및 R</span><span class="sxs-lookup"><span data-stu-id="d49a6-106">Recommendation systems and R</span></span>

<span data-ttu-id="d49a6-107">소매업체의 경우 소비자의 선호도와 구매 이력을 이해하는 것은 경쟁적 우위 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-107">For a retailer, understanding consumer preferences and purchasing history is a competitive advantage.</span></span> <span data-ttu-id="d49a6-108">소매업체는 수년간 기계 학습과 함께 이러한 데이터를 사용하여 소비자와 관련된 제품을 식별하고 개인 설정된 쇼핑 환경을 제공해 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-108">Retailers have been using such data for years, in combination with machine learning, to identify products relevant to the consumer and deliver a personalized shopping experience.</span></span> <span data-ttu-id="d49a6-109">이 방법을 **제품 권장 사항**이라고 하며, 소매업체에게 상당한 수익 흐름을 창출합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-109">The approach is called **product recommendation** and it generates a significant revenue stream for retailers.</span></span> <span data-ttu-id="d49a6-110">권장 시스템은 다음과 같은 질문에 답변하는 데 도움이 됩니다. *이 사람은 다음에 어떤 영화를 볼까요? 이 고객은 어떤 추가 서비스에 관심을 가질까요? 이 고객은 어디에서 휴가를 보내려고 할까요?*</span><span class="sxs-lookup"><span data-stu-id="d49a6-110">Recommendation systems help answer questions like: *What movie will this person watch next? What additional services is this customer likely to be interested in? Where will this customer want to vacation?*</span></span>
<span data-ttu-id="d49a6-111">최근에 고객은 *소비자(구독자)가 계약을 갱신할까요?* 라는 질문에 대한 답을 알려고 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-111">A recent customer wanted to know: *Will consumers (subscribers) renew their contracts?*</span></span> <span data-ttu-id="d49a6-112">고객은 구독자가 계약을 갱신할 확률을 예측하는 기존 권장 모델을 가지고 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-112">The customer had an existing recommendation model that would forecast the probability of a subscriber renewing a contract.</span></span> <span data-ttu-id="d49a6-113">예측이 생성되면 추가 처리가 적용되어 응답을 예, 아니요 또는 나중에 결정으로 분류했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-113">Once the forecast was generated, additional processing was applied to classify a response into a yes, no, or maybe.</span></span> <span data-ttu-id="d49a6-114">그런 다음, 모델 응답은 호출 센터 비즈니스 프로세스에 통합되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-114">The model response was then integrated into a call center business process.</span></span> <span data-ttu-id="d49a6-115">이 프로세스를 통해 서비스 에이전트는 사용자에게 개인화된 권장 사항을 전달할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-115">That process enabled a service agent to deliver a personalized recommendation to the consumer.</span></span>  
<span data-ttu-id="d49a6-116">이 고객의 초기 분석 제품 중 대다수는 권장 시스템의 핵심에 있는 기계 학습 모델을 포함하여 [R 프로그래밍 언어](https://docs.microsoft.com/machine-learning-server/rebranding-microsoft-r-server)로 구축되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-116">Many of this customer’s early analytic products were built in the [programming language R](https://docs.microsoft.com/machine-learning-server/rebranding-microsoft-r-server), including the machine learning model at the core of their recommendation system.</span></span> <span data-ttu-id="d49a6-117">구독자 기반이 커짐에 따라 데이터와 계산 요구 사항도 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-117">As their subscriber base has grown, so have the data and compute requirements.</span></span> <span data-ttu-id="d49a6-118">따라서 권장 워크로드가 이제는 매우 느리고 처리하기가 번거롭습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-118">So much so, the recommendation workload is now painfully slow and cumbersome to process.</span></span> <span data-ttu-id="d49a6-119">이제 Python은 점차적으로 분석 제품 전략의 일부가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-119">Now Python is increasingly a part of their analytic product strategy.</span></span> <span data-ttu-id="d49a6-120">그러나 가까운 시일 내에 R 투자를 유지하고 더 효율적인 개발 및 배포 프로세스를 찾아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-120">But for the near term, they need to preserve their R investment and find a more efficient development and deployment process.</span></span> <span data-ttu-id="d49a6-121">과제는 Azure의 기능을 사용하여 기존 방식을 최적화하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-121">The challenge was to optimize the existing approach using capabilities in Azure.</span></span> <span data-ttu-id="d49a6-122">권장 워크로드에 개념 증명 기술 스택을 제공하고 유효성을 검사하는 작업에 착수했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-122">We embarked on a task to provide—and validate—a proof-of-concept technology stack for the recommendation workload.</span></span> <span data-ttu-id="d49a6-123">여기에는 비슷한 프로젝트에 사용할 수 있는 일반적인 방법이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-123">Here we summarize a general approach that can be used for similar projects.</span></span>  

## <a name="design-goals"></a><span data-ttu-id="d49a6-124">설계 목표</span><span class="sxs-lookup"><span data-stu-id="d49a6-124">Design goals</span></span>

<span data-ttu-id="d49a6-125">주요 우선 순위는 모델 워크플로를 재설계 및 자동화하여 다음과 같은 몇 가지 이점을 제공하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-125">A key priority was to redesign and automate the model workflow to provide several advantages:</span></span>

- <span data-ttu-id="d49a6-126">모델 개발 주기 단축 및 혁신 시간 단축.</span><span class="sxs-lookup"><span data-stu-id="d49a6-126">Faster model development cycles and faster time-to-innovate.</span></span> <span data-ttu-id="d49a6-127">데이터 준비 및 모델 개발 주기가 효율적이면 실험의 양이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-127">When data preparation and model development cycles are efficient, the volume of experiments can increase.</span></span>  
- <span data-ttu-id="d49a6-128">새 데이터에 대한 더 빈번한 재학습 주기를 통해 더 정확한 모델 결과 및 더 나은 권장 사항 제공</span><span class="sxs-lookup"><span data-stu-id="d49a6-128">More accurate model results and better recommendations through more frequent retraining cycles on fresh data.</span></span>
- <span data-ttu-id="d49a6-129">확장성이 더 뛰어난 POC(개념 증명) 구현 - 전체 프로덕션에서 작동</span><span class="sxs-lookup"><span data-stu-id="d49a6-129">A more scalable proof-of-concept (POC) implementation—one that would work in full production.</span></span>
- <span data-ttu-id="d49a6-130">개발, 테스트 및 배포 프로세스를 자동화하여 프로덕션 시간 단축.</span><span class="sxs-lookup"><span data-stu-id="d49a6-130">Faster time to production by automating the processes between development, test, and deployment.</span></span> <span data-ttu-id="d49a6-131">또한 자동화를 통해 운영 오류와 지연 기간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-131">Automation also reduces operational errors and lag times.</span></span>  

## <a name="requirements"></a><span data-ttu-id="d49a6-132">요구 사항</span><span class="sxs-lookup"><span data-stu-id="d49a6-132">Requirements</span></span>

<span data-ttu-id="d49a6-133">워크플로 재설계에는 다음과 같은 요구 사항이 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-133">The workflow redesign had the following requirements:</span></span>

- <span data-ttu-id="d49a6-134">팀의 기존 R 기술 및 전문 지식을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-134">Leverage the team’s existing R skills and expertise.</span></span>
- <span data-ttu-id="d49a6-135">의미가 있는 위치에서 코드를 다시 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-135">Reuse code where it made sense.</span></span>
- <span data-ttu-id="d49a6-136">모델 학습 및 재학습 프로세스에 빠르고 쉽게 통합될 수 있도록 구독자 데이터를 데이터베이스에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-136">Store subscriber data in a database to be easily and quickly integrated into the model training and retraining process.</span></span>
- <span data-ttu-id="d49a6-137">웹앱 인터페이스를 통해 다시 학습하고 점수를 매기는 모델을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-137">Invoke model retraining and scoring through a web app interface.</span></span>
- <span data-ttu-id="d49a6-138">Azure Active Directory를 사용하여 웹 프런트 엔드에서 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-138">Use Azure Active Directory for authentication on the web front end.</span></span>

## <a name="technology-stack"></a><span data-ttu-id="d49a6-139">기술 스택</span><span class="sxs-lookup"><span data-stu-id="d49a6-139">Technology stack</span></span>

<span data-ttu-id="d49a6-140">이 프로젝트에 대한 파이프라인에는 여러 기술과 도구가 필요했으며 다음 네 가지 영역에 집중되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-140">The pipeline for this project required multiple technologies and tools and centered around four areas:</span></span>

1. <span data-ttu-id="d49a6-141">구독자 데이터의 지속성 및 접근성</span><span class="sxs-lookup"><span data-stu-id="d49a6-141">Persistence and accessibility of subscriber data.</span></span>
2. <span data-ttu-id="d49a6-142">모델의 개발, 학습 및 선택</span><span class="sxs-lookup"><span data-stu-id="d49a6-142">Development, training, and selection of models.</span></span>  
3. <span data-ttu-id="d49a6-143">배포 및 운영화 모델링</span><span class="sxs-lookup"><span data-stu-id="d49a6-143">Model deployment and operationalization.</span></span>
4. <span data-ttu-id="d49a6-144">웹 애플리케이션을 사용하여 점수 매기기 및 모델 재학습 모델 호출</span><span class="sxs-lookup"><span data-stu-id="d49a6-144">Use of a web application to invoke scoring and model re-training.</span></span>

<span data-ttu-id="d49a6-145">파이프라인 다이어그램의 기술 구성 요소에 대해 아래에서 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-145">The technology components in the pipeline diagram are discussed in more detail below.</span></span>

![최적화 아키텍처](assets/recommendation-engine-optimization/recommendation-architecture.png)

### <a name="microsoft-machine-learning-server"></a><span data-ttu-id="d49a6-147">Microsoft Machine Learning 서버</span><span class="sxs-lookup"><span data-stu-id="d49a6-147">Microsoft Machine Learning Server</span></span>

<span data-ttu-id="d49a6-148">R 워크로드를 선택하는 주된 이유는 **[RevoScaleR](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/revoscaler)** 및 **Microsoft ML**입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-148">The primary reason for selecting R workloads: **[RevoScaleR](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/revoscaler)** and **Microsoft ML**.</span></span> <span data-ttu-id="d49a6-149">이러한 패키지에 포함된 함수는 코드 전체에서 광범위하게 사용되어 데이터를 가져오고, 분류 모델을 만들고, 이를 프로덕션 환경에 배포했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-149">The functions included with these packages were used extensively throughout the code to import the data, create the classification models, and deploy them into production.</span></span>
<span data-ttu-id="d49a6-150">MLS는 Azure에서 두 개의 Linux 가상 머신에 배포되었습니다. 하나는 "개발"용으로, 다른 하나는 "운영"용으로 구성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-150">MLS was deployed on two Linux virtual machines in Azure: one configured for “development” and one configured for “operations.”</span></span> <span data-ttu-id="d49a6-151">훨씬 더 많은 메모리와 처리 능력을 갖춘 개발 VM을 프로비전하여 수백 개의 모델을 학습하고 테스트할 수 있도록 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-151">The development VM was provisioned with significantly more memory and processing power to facilitate the training and testing of hundreds of models.</span></span> <span data-ttu-id="d49a6-152">또한 원격 사용자를 위해 RStudio IDE에 쉽게 액세스할 수 있도록 RStudio Server도 호스팅했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-152">It also hosted RStudio Server to provide easy access to an RStudio IDE for remote users.</span></span> <span data-ttu-id="d49a6-153">운영 서버는 REST API를 통해 웹 애플리케이션에서 호출할 수 있는 R 모델을 호스팅하는 데 필요한 추가 확장을 갖춘 더 작은 VM에 구성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-153">The operations server was configured on a smaller VM with the additional extensions necessary to host R models that were callable from a web application through REST APIs.</span></span>

### <a name="rstudio-server"></a><span data-ttu-id="d49a6-154">RStudio Server</span><span class="sxs-lookup"><span data-stu-id="d49a6-154">RStudio Server</span></span>

<span data-ttu-id="d49a6-155">**[RStudio Server](https://www.rstudio.com/products/rstudio/#Server)** 는 원격 또는 랩톱 클라이언트에 대한 브라우저 기반 인터페이스를 제공하는 Linux 애플리케이션입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-155">**[RStudio Server](https://www.rstudio.com/products/rstudio/#Server)** is a Linux application that provides a browser-based interface for remote or laptop clients.</span></span> <span data-ttu-id="d49a6-156">Azure VM에 네트워크 보안 규칙이 만들어지면, 8787 포트에서 실행되며 원격 연결에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-156">It runs on port 8787 and is available to remote connections once a network security rule is created on the Azure VM.</span></span> <span data-ttu-id="d49a6-157">RStudio IDE를 선호하는 분석가 및 데이터 과학자에게 큰 계산 및 메모리 용량을 갖춘 가상 머신에 대한 액세스를 제공하는 효율적인 옵션이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-157">For analysts and data scientists who prefer the RStudio IDE, it can be an efficient option for providing access to virtual machine with a large compute and memory capacity.</span></span> <span data-ttu-id="d49a6-158">원본 및 상용 버전 모두에서 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-158">It is available for download in both source and commercial editions.</span></span>

### <a name="azure-sql-database"></a><span data-ttu-id="d49a6-159">Azure SQL Database</span><span class="sxs-lookup"><span data-stu-id="d49a6-159">Azure SQL Database</span></span>

<span data-ttu-id="d49a6-160">원래 구독자 데이터는 500명의 고유 구독자를 위해 600만 개 행의 구매 및 기본 설정 정보가 포함된 하나의 매우 큰 .csv 파일에 저장되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-160">Originally, the subscriber data was stored in one very large .csv file with 6 million rows of purchasing and preference information for 500 unique subscribers.</span></span> <span data-ttu-id="d49a6-161">데이터베이스에 데이터를 저장하는 것은 R 내의 더 빠른 데이터 액세스를 의미하며 필터링된 읽기를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-161">Storing the data in a database meant faster data access from within R and it would allow for filtered reads.</span></span> <span data-ttu-id="d49a6-162">학습 또는 재학습을 위해 더 이상 전체 데이터 세트를 가져올 필요가 없습니다. 구독자가 데이터베이스 원본의 데이터를 필터링하여 데이터를 가져오고 처리하는 데 필요한 리소스가 크게 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-162">No longer would the entire data set need to be imported for training or retraining: data would be filtered by subscriber at the database source, significantly reducing the resources needed to import and process the data.</span></span>  
<span data-ttu-id="d49a6-163">Azure에는 몇 가지 관리 클라우드 데이터베이스 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-163">There are several managed cloud database options in Azure.</span></span> <span data-ttu-id="d49a6-164">고객이 SQL Server에 익숙하므로 [Azure SQL Database](https://docs.microsoft.com/azure/sql-database/)가 선택되었으며, 더 중요한 것은 향후 더 광범위한 규모의 Azure SQL Database에 SQL Server Machine Learning Services를 도입할 계획입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-164">[Azure SQL Database](https://docs.microsoft.com/azure/sql-database/) was selected because of the customer’s familiarity with SQL Server and—more importantly—future plans to introduce SQL Server Machine Learning Services on a broader scale to Azure SQL Database.</span></span> <span data-ttu-id="d49a6-165">[SQL Server Machine Learning Services](https://docs.microsoft.com/sql/advanced-analytics/what-is-sql-server-machine-learning?view=sql-server-2017)는 저장 프로시저를 통해 R 및 Python 워크로드를 실행하기 위한 데이터베이스 내 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-165">[SQL Server Machine Learning Services](https://docs.microsoft.com/sql/advanced-analytics/what-is-sql-server-machine-learning?view=sql-server-2017) are in-database capabilities for executing R and Python workloads via stored procedures.</span></span>

### <a name="nodejs-and-reactjs"></a><span data-ttu-id="d49a6-166">Node.js 및 React.js</span><span class="sxs-lookup"><span data-stu-id="d49a6-166">Node.js and React.js</span></span>

<span data-ttu-id="d49a6-167">R 스크립트를 호출하고 웹 사이트를 보호하기 위한 웹 인터페이스가 만들어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-167">A web interface was created to invoke R scripts and secure the website.</span></span> <span data-ttu-id="d49a6-168">Node.js는 분산 환경 내에서 웹 애플리케이션을 위한 가볍고 효율적인 런타임 환경을 가능하게 하므로 웹 서버 프레임워크로 선택되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-168">Node.js was selected as the web server framework because it enables a light-weight and efficient runtime environment for web applications within a distributed environment.</span></span> <span data-ttu-id="d49a6-169">React는 사용자 인터페이스를 작성하는 데 사용되며, 프런트 엔드에 위치하고, 웹 서버에서 호스팅되는 웹 서비스를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-169">React is used to build user interfaces and sits on the front end and calls web services hosted on the web server.</span></span> <span data-ttu-id="d49a6-170">Node 및 React에서 모델 파이프라인의 프로토타입 생성 웹 서비스에 대한 가장 빠른 경로를 제공할 것으로 믿었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-170">It was believed Node + React would provide the quickest path for proto-typing web services for the model pipeline.</span></span>  

## <a name="infrastructure-implementation"></a><span data-ttu-id="d49a6-171">인프라 구현</span><span class="sxs-lookup"><span data-stu-id="d49a6-171">Infrastructure implementation</span></span>

<span data-ttu-id="d49a6-172">아래 섹션에서는 이 프로젝트를 위해 서버 인프라가 배포된 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-172">The sections below describe how the server infrastructure was deployed for this project.</span></span> <span data-ttu-id="d49a6-173">적절한 개발 및 배포 인프라를 확보하는 것은 적용될 모델링 방법과 기술을 결정하는 것만큼 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-173">Getting the right development and deployment infrastructure can be as essential as determining the modeling approach and techniques that will be applied.</span></span>

### <a name="initial-database-load"></a><span data-ttu-id="d49a6-174">초기 데이터베이스 로드</span><span class="sxs-lookup"><span data-stu-id="d49a6-174">Initial Database Load</span></span>

<span data-ttu-id="d49a6-175">첫 번째 단계는 매우 큰 .csv 파일에서 Azure SQL Database로 구독자 데이터를 가져오는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-175">The first step was to import the subscriber data from a very large .csv file into Azure SQL Database.</span></span> <span data-ttu-id="d49a6-176">Azure SQL Database로 데이터를 가져오는 여러 가지 옵션이 있으며, 이 [참고 자료](https://blogs.msdn.microsoft.com/sqlcat/2010/07/30/loading-data-to-sql-azure-the-fast-way/)에서 설명하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-176">There are multiple options for importing data into Azure SQL Database described in in this [reference](https://blogs.msdn.microsoft.com/sqlcat/2010/07/30/loading-data-to-sql-azure-the-fast-way/).</span></span> <span data-ttu-id="d49a6-177">작업을 수행한 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-177">Here is how we did it:</span></span>

1. <span data-ttu-id="d49a6-178">[여기](https://docs.microsoft.com/azure/sql-database/sql-database-get-started-portal)의 단계에 따라 Azure Portal을 통해 데이터베이스를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-178">Created the database through Azure portal following steps [here](https://docs.microsoft.com/azure/sql-database/sql-database-get-started-portal).</span></span>
2. <span data-ttu-id="d49a6-179">[SQL Server Management Studio](https://docs.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)를 다운로드하여 VM에서 데이터베이스에 연결하는 데 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-179">Downloaded and used [SQL Server Management Studio](https://docs.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017) to connect to the database from the VM.</span></span>
3. <span data-ttu-id="d49a6-180">[SQL 가져오기/내보내기 마법사](https://docs.microsoft.com/sql/integration-services/import-export-data/import-and-export-data-with-the-sql-server-import-and-export-wizard?view=sql-server-2017)를 선택했습니다(시간 제한이 있는 경우 성능이 더 뛰어난 데이터 가져오기 옵션이 있음).</span><span class="sxs-lookup"><span data-stu-id="d49a6-180">Selected the [SQL Import/Export Wizard](https://docs.microsoft.com/sql/integration-services/import-export-data/import-and-export-data-with-the-sql-server-import-and-export-wizard?view=sql-server-2017) (if you are time-constrained, there are more performant data import options).</span></span> <span data-ttu-id="d49a6-181">가져오기/내보내기 마법사는 데이터 형식을 데이터 원본에서 대상으로 매핑하며, 이 시나리오에서는 모든 데이터 요소가 허용되는 varchar(max) 데이터 형식에 매핑되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-181">Keep in mind the import/export wizard maps datatypes from the data source to the target destination; and with our scenario, all data elements were mapped to a varchar(max) data type which was acceptable.</span></span> <span data-ttu-id="d49a6-182">시나리오에 다른 매핑이 필요하면 마법사에서 데이터 형식을 수정할 수 있습니다([참고 자료](https://docs.microsoft.com/sql/integration-services/import-export-data/data-type-mapping-in-the-sql-server-import-and-export-wizard?view=sql-server-2017)).</span><span class="sxs-lookup"><span data-stu-id="d49a6-182">If your scenario requires different mappings, you can modify the datatypes in the wizard ([reference](https://docs.microsoft.com/sql/integration-services/import-export-data/data-type-mapping-in-the-sql-server-import-and-export-wizard?view=sql-server-2017)).</span></span>  
4. <span data-ttu-id="d49a6-183">데이터베이스에 제출된 대부분의 쿼리는 *subscriber_id* 필드를 필터링하므로 해당 필드에 대한 인덱스를 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-183">Since most queries submitted to the database would filter on the field *subscriber_id*, we created an index on that field.</span></span>

### <a name="web-application"></a><span data-ttu-id="d49a6-184">웹 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="d49a6-184">Web application</span></span>

<span data-ttu-id="d49a6-185">웹 애플리케이션은 다음 세 가지 함수를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-185">The web application is responsible for three functions:</span></span>

- <span data-ttu-id="d49a6-186">인증: 웹 사용자가 *React* 프런트 엔드를 통해 *Azure Active Directory*에 대해 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-186">Authentication: web users authenticate against *Azure Active Directory* through the *React* front end.</span></span>
- <span data-ttu-id="d49a6-187">모델 점수 매기기: 특정 구독자에 대한 사용자의 입력 데이터를 받아들이고, REST API를 사용하여 구독자 데이터를 웹 서비스에 제출하고, 예측 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-187">Model scoring: accepts input data from the user for a specific subscriber, submits the subscriber data to the web service using the REST API, which returns a prediction response.</span></span>  
- <span data-ttu-id="d49a6-188">모델 재학습: 구독자 식별자를 입력으로 받아들이고, 개발 서버에서 R 스크립트를 호출하여 해당 구독자에 대한 모델을 다시 학습합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-188">Model re-training: accepts a subscriber identifier as input an,d invokes an R script on the development server to re-train the model for that subscriber.</span></span>

<span data-ttu-id="d49a6-189">*Azure Active Directory*에서 SSO(Single Sign-On)를 구현하는 것은 예상보다 더 어려운 과제였습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-189">Implementing single sign-on (SSO) with *Azure Active Directory* turned out to be more of a challenge than expected.</span></span> <span data-ttu-id="d49a6-190">이는 SPA(단일 페이지 애플리케이션) 프레임워크 때문이었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-190">This was due to the single page application (SPA) framework.</span></span> <span data-ttu-id="d49a6-191">특정 Azure Active Directory 라이브러리, 즉 [react-adal](https://github.com/salvoravida/react-adal)이 성공의 열쇠였습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-191">One specific Azure Active Directory library was key for success: [react-adal](https://github.com/salvoravida/react-adal).</span></span> <span data-ttu-id="d49a6-192">다음 참고 자료에서는 인증 구현에 유용한 지침을 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-192">The following references provided helpful guidance for implementing authentication:</span></span>

- [<span data-ttu-id="d49a6-193">Azure AD의 인증 시나리오</span><span class="sxs-lookup"><span data-stu-id="d49a6-193">Authentication Scenarios for Azure AD</span></span>](https://docs.microsoft.com/azure/active-directory/develop/active-directory-authentication-scenarios)
- [<span data-ttu-id="d49a6-194">단일 페이지 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="d49a6-194">Single Page Application</span></span>](https://docs.microsoft.com/azure/active-directory/develop/active-directory-authentication-scenarios#single-page-application-spa)

### <a name="development-vm-mls-930"></a><span data-ttu-id="d49a6-195">개발 VM(MLS 9.3.0)</span><span class="sxs-lookup"><span data-stu-id="d49a6-195">Development VM (MLS 9.3.0)</span></span>

<span data-ttu-id="d49a6-196">개발 VM은 분류 모델의 개발, 학습, 재학습 및 배포를 호스팅했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-196">The development VM hosted model development, training and re-training, and deployment of the classification model.</span></span> <span data-ttu-id="d49a6-197">Azure VM(DS13 V2)이 Linux/Ubuntu 16.10을 통해 프로비전되었으며 다음 항목이 기본 VM에 설치되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-197">An Azure VM (DS13 V2) was provisioned with Linux/Ubuntu 16.10 and the following were installed to the base VM:</span></span>

- <span data-ttu-id="d49a6-198">[여기](https://docs.microsoft.com/machine-learning-server/install/machine-learning-server-install)서 사용할 수 있는 지침에 따라 Machine Learning Server 9.3.0을 설치했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-198">Machine Learning Server 9.3.0 using instructions available [here](https://docs.microsoft.com/machine-learning-server/install/machine-learning-server-install).</span></span> <span data-ttu-id="d49a6-199">설치 확인 단계를 통해 실행하여 설치를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-199">Be sure to run through the setup verification steps to confirm the installation.</span></span> <span data-ttu-id="d49a6-200">이 설치는 개발 VM이므로 '*웹 서비스 배포 및 원격 연결 사용*' 섹션이 무시되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-200">Because this was the development VM, the section ‘*Enable web service deployment and remote connections*’ was disregarded.</span></span>
- <span data-ttu-id="d49a6-201">[RStudio Server](https://www.rstudio.com/products/rstudio/download-server/)(오픈 소스 버전)를 설치했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-201">[RStudio Server](https://www.rstudio.com/products/rstudio/download-server/) (Open Source Version).</span></span> <span data-ttu-id="d49a6-202">R/r-base(이전에 MLS 9.3.0과 함께 설치됨)를 다시 설치하지 않도록 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="d49a6-202">Be careful not to re-install R/r-base (it was installed previously with MLS 9.3.0).</span></span>  
- <span data-ttu-id="d49a6-203">VM에 [네트워크 보안 그룹을 추가](https://docs.microsoft.com/azure/virtual-machines/windows/nsg-quickstart-portal)하여 RStudio Server에 8787 포트를 통한 인바운드 연결을 허용했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-203">[Add a network security group](https://docs.microsoft.com/azure/virtual-machines/windows/nsg-quickstart-portal) to the VM to allow for inbound connections over port 8787 for RStudio Server.</span></span>  
- <span data-ttu-id="d49a6-204">개발 VM과 Azure SQL Database 간의 통신을 처리하는 ODBC 드라이버를 설치했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-204">ODBC drivers to handle the communication between the development VM and Azure SQL Database.</span></span> <span data-ttu-id="d49a6-205">VM에 설치된 ODBC 드라이버는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-205">The following odbc drivers were installed on the VM:</span></span>  
- <span data-ttu-id="d49a6-206">Linux/Ubuntu 16.10과 호환되는 [SQL Server 17용 ODBC 드라이버](https://www.microsoft.com/download/details.aspx?id=56567)</span><span class="sxs-lookup"><span data-stu-id="d49a6-206">The [ODBC Driver for SQL Server 17](https://www.microsoft.com/download/details.aspx?id=56567) compatible with Linux/ubuntu 16.10</span></span>  
- <span data-ttu-id="d49a6-207">[ODBC를 사용하여 관계형 데이터 가져오기](https://docs.microsoft.com/machine-learning-server/r/how-to-revoscaler-data-odbc)의 설치 지침에 따라 설치된 unixodbc 오픈 소스 ODBC 드라이버.</span><span class="sxs-lookup"><span data-stu-id="d49a6-207">An open source ODBC driver unixodbc with installation instructions from [Import relational data using ODBC](https://docs.microsoft.com/machine-learning-server/r/how-to-revoscaler-data-odbc).</span></span> <span data-ttu-id="d49a6-208">참고: 이 문서에는 Ubuntu 지침에 대한 두 가지 오타가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-208">Note: this article has two typos for Ubuntu instructions.</span></span>  
- <span data-ttu-id="d49a6-209">unixodbc가 설치되어 있는지 확인하는 경우: ````Apt list –installed | grep unixODBC (should be unixodbc)````</span><span class="sxs-lookup"><span data-stu-id="d49a6-209">To check if unixodbc is installed:       ````Apt list –installed | grep unixODBC (should be unixodbc)````</span></span>
      - <span data-ttu-id="d49a6-210">드라이버를 설치하는 경우: ````sudo apt-get install unixodbc-devel unixodbc-bin unixodbc (should be unixodbc-dev)````</span><span class="sxs-lookup"><span data-stu-id="d49a6-210">And to install the driver: ````sudo apt-get install unixodbc-devel unixodbc-bin unixodbc (should be unixodbc-dev)````</span></span>

### <a name="operations-vm-mls-930"></a><span data-ttu-id="d49a6-211">운영 VM(MLS 9.3.0)</span><span class="sxs-lookup"><span data-stu-id="d49a6-211">Operations VM (MLS 9.3.0)</span></span>

<span data-ttu-id="d49a6-212">운영 VM은 모델 웹 서비스 및 엔드포인트를 호스팅하고, Swagger 파일을 저장하며, 분류 모델의 직렬화된 버전을 저장했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-212">The operations VM hosted the model web services and endpoints, stored the Swagger files, and stored serialized versions of the classification models.</span></span> <span data-ttu-id="d49a6-213">구성은 MLS 개발 서버와 매우 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-213">Configuration is very similar to the MLS development server.</span></span> <span data-ttu-id="d49a6-214">그러나 이는 REST 엔드포인트를 제공하는 데 필요한 웹 서비스가 설치되어 있음을 의미하는 운영화에 대해 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-214">However, it is configured for operationalization which means the web services necessary to serve the REST endpoints are installed.</span></span> <span data-ttu-id="d49a6-215">운영 VM을 배포하기 위해 빠르게 배포할 수 있는 ARM 템플릿이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-215">To deploy the operations VM, there are ARM templates that make deployment quick.</span></span> <span data-ttu-id="d49a6-216">자세한 내용은 [ARM 템플릿을 사용하여 분석을 운영하도록 Microsoft Machine Learning Server 9.3 구성](https://blogs.msdn.microsoft.com/mlserver/2018/02/27/configuring-microsoft-machine-learning-server-9-3-to-operationalize-analytics-using-arm-templates/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d49a6-216">See: [Configuring Microsoft Machine Learning Server 9.3 to Operationalize Analytics using ARM Templates](https://blogs.msdn.microsoft.com/mlserver/2018/02/27/configuring-microsoft-machine-learning-server-9-3-to-operationalize-analytics-using-arm-templates/).</span></span> <span data-ttu-id="d49a6-217">이 프로젝트의 경우 이 [ARM 템플릿](https://github.com/Microsoft/microsoft-r/tree/master/mlserver-arm-templates/one-box-configuration/linux)을 사용하여 *One-Box* 구성이 배포되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-217">For our project, a *One-Box* configuration was deployed using this [ARM template](https://github.com/Microsoft/microsoft-r/tree/master/mlserver-arm-templates/one-box-configuration/linux).</span></span>  
<span data-ttu-id="d49a6-218">이를 통해 모델 파이프라인을 지원하는 서버 구성 요소가 가동되어 실행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-218">With this, the server components to support the model pipeline were up and running.</span></span>

## <a name="model-implementation"></a><span data-ttu-id="d49a6-219">모델 구현</span><span class="sxs-lookup"><span data-stu-id="d49a6-219">Model implementation</span></span>

<span data-ttu-id="d49a6-220">한 가지 중요한 결정은 이 프로젝트의 최종 모델 설계에 영향을 미쳤으며, 단일 모놀리식 모델이 아니라 "여러 모델" 설계로 전환하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-220">One key decision influenced the final model design for this project and that was to move to a “many model” design rather than a single, monolithic model.</span></span> <span data-ttu-id="d49a6-221">차이점은 각 구독자에게 모든 구독자에게 서비스를 제공하는 하나의 큰 분류 모델이 아니라 자신의 고유한 분류 모델이 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-221">The difference: each subscriber has their own classification model rather than one big classification model to serve all subscribers.</span></span> <span data-ttu-id="d49a6-222">이 고객의 경우 모델이 작을수록 메모리 공간이 더 작고 프로덕션에서 수평으로 확장하기가 더 쉽기 때문에 이 방법을 선호했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-222">For this customer, the approach was preferred because a smaller model had a smaller memory footprint and was easier to scale horizontally in production.</span></span>

### <a name="data-import"></a><span data-ttu-id="d49a6-223">데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="d49a6-223">Data import</span></span>

<span data-ttu-id="d49a6-224">모델 개발에 필요한 모든 데이터는 *Azure SQL Database*에 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-224">All the data needed for model development resided in an *Azure SQL Database*.</span></span> <span data-ttu-id="d49a6-225">모델 학습 및 재학습의 경우 데이터 가져오기는 다음 두 단계로 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-225">For model training and retraining, data import was done in two stages:</span></span>

1. <span data-ttu-id="d49a6-226">특정 *subscriber_id*에 대한 데이터를 검색하는 쿼리가 데이터베이스에 제출되었으며 결과 세트가 반환되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-226">A query was submitted to the database to retrieve data for a specific *subscriber_id* and a result set returned.</span></span> <span data-ttu-id="d49a6-227">데이터베이스에 대한 쿼리 액세스에 대해 다음 두 가지 옵션이 고려되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-227">Two options were considered for query access to the database:</span></span>

- <span data-ttu-id="d49a6-228">[RxSQLServerData](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rxsqlserverdata)라는 RevoScaleR 함수</span><span class="sxs-lookup"><span data-stu-id="d49a6-228">A RevoScaleR function called [RxSQLServerData](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rxsqlserverdata)</span></span>
- <span data-ttu-id="d49a6-229">R odbc 패키지</span><span class="sxs-lookup"><span data-stu-id="d49a6-229">The R odbc package</span></span>

<span data-ttu-id="d49a6-230">데이터베이스 수준에서 데이터 필터링을 사용하도록 설정한 R "odbc" 라이브러리를 사용하도록 결정했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-230">It was decided to use the R “odbc” library which enabled data filtering at the database level.</span></span> <span data-ttu-id="d49a6-231">특정 구독자 모델에 필요한 행에 대해서만 데이터베이스 테이블을 필터링한 경우 R로 읽어들여 처리하는 행 수가 최소화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-231">Filtering the database table for only the rows needed for a specific subscriber model minimized the number of rows to be read into R and processed.</span></span> <span data-ttu-id="d49a6-232">이를 통해 각 모델을 학습하거나 다시 학습하는 데 필요한 메모리, 계산 및 전체 시간을 줄일 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-232">That reduced the memory, compute, and overall time needed to train or retrain each model.</span></span>  

1. <span data-ttu-id="d49a6-233">결과 세트는 R 데이터 프레임으로 변환되었으며, 데이터 형식 중 일부는 은 분류 알고리즘에서 요구하는 대로 varchar에서 정수 또는 숫자로 명시적으로 변환되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-233">The result set was converted into an R data frame and some of the data types were explicitly converted from varchars to integers or numerics as required by the classification algorithms.</span></span> <span data-ttu-id="d49a6-234">이 기능에는 [rxImport](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rximport) RevoScaleR 함수가 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-234">For this functionality, the RevoScaleR function [rxImport](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rximport) was used.</span></span> <span data-ttu-id="d49a6-235">*rxImport* 함수는 RevoScaleR 및 MicrosoftML과 함께 번들로 제공되며 다중 스레드로 계층화되도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-235">The *rxImport* function is bundled with RevoScaleR and MicrosoftML and is engineered to be multi-threaded.</span></span> <span data-ttu-id="d49a6-236">사용한 방법에 대한 예제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-236">Here is an example of how we used it:</span></span>

````r

# Populate the data frame and modify column types as needed
input_data <- rxImport(sqlServerDataDS, colClasses = c(  
Approved="integer",
      OnTimeArrivalRate="numeric",
      Amount="numeric",
      IsInformed="numeric",
      <continue with list of columns> )
# View the characteristics of the variables in the data source
rxGetInfo (input_data, getVarInfo = TRUE)
````

## <a name="unbalanced-data"></a><span data-ttu-id="d49a6-237">불균형 데이터</span><span class="sxs-lookup"><span data-stu-id="d49a6-237">Unbalanced data</span></span>

<span data-ttu-id="d49a6-238">권장 모델의 목표는 고객이 계약을 갱신할 확률을 예측하고 이 확률을 '예', '아니요' 또는 '나중에 결정'으로 분류하는 것이었으므로 분류 알고리즘이 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-238">Because the goal of the recommendation model was to forecast the probability a customer would renew a contract and categorize the probability it into a ‘yes’, ‘no’, or ‘maybe’, a classification algorithm was used.</span></span> <span data-ttu-id="d49a6-239">분류 알고리즘의 정확성과 성능에 심각한 영향을 줄 수 있는 한 가지 문제는 불균형 데이터 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-239">One problem that can seriously impact the accuracy and performance of a classification algorithm is an unbalanced data set.</span></span>  
<span data-ttu-id="d49a6-240">한 '클래스'에 대한 샘플이 다른 '클래스'보다 더 많은 경우 데이터 세트의 균형이 맞지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-240">A data set is unbalanced if there are many more samples for one ‘class’ than another ‘class’.</span></span> <span data-ttu-id="d49a6-241">이 경우 각 구독자가 사용할 수 있는 행의 수가 균형을 이루지 못했습니다. 최댓값에는 한 구독자에게 100만 개 이상의 행이 있었고, 최솟값에는 330명의 고객에게 100개 미만의 데이터 행이 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-241">In this case, the number of rows available for each subscriber was unbalanced: on the high end, one subscriber had 1 million+ rows; on the low end, 330 customers had less than 100 rows of data.</span></span> <span data-ttu-id="d49a6-242">아래 그래프에서는 구독자당 행 수(샘플)에 따른 불균형을 보여 줍니다. ![imbalance-chart](assets/recommendation-engine-optimization/recommendaton_engine_chart.png)</span><span class="sxs-lookup"><span data-stu-id="d49a6-242">The graph below shows the imbalance with the number of rows (samples) per subscriber: ![imbalance-chart](assets/recommendation-engine-optimization/recommendaton_engine_chart.png)</span></span>

<span data-ttu-id="d49a6-243">불균형 데이터 세트를 처리하는 한 가지 방법은 데이터 세트를 변경하고 과소 표시된 클래스를 과다 샘플링하거나 과다 표시된 클래스를 과소 샘플링하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-243">One technique for treating an unbalanced data set is to change the data set and either over-sample the under-represented class, or under-sample the over-represented class.</span></span> <span data-ttu-id="d49a6-244">또 다른 방법은 데이터 소유자가 데이터와 해당 특성에 대한 정확한 지식을 사용하여 추가 데이터를 합성하여 생성하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-244">Another technique is to synthetically generate additional data using the data owner’s exact knowledge of the data and its attributes.</span></span> <span data-ttu-id="d49a6-245">고객은 구독자에 대한 최소 샘플 크기의 임계값을 설정했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-245">The customer established a threshold for the minimum sample size for a subscriber.</span></span> <span data-ttu-id="d49a6-246">이 임계값 미만의 구독자에 대한 데이터를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-246">For subscribers below that threshold, data would need to be treated.</span></span> <span data-ttu-id="d49a6-247">이 프로젝트에서 두 가지 방법을 모두 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-247">For this project both approaches were explored.</span></span>

## <a name="algorithm-selection"></a><span data-ttu-id="d49a6-248">알고리즘 선택</span><span class="sxs-lookup"><span data-stu-id="d49a6-248">Algorithm Selection</span></span>

<span data-ttu-id="d49a6-249">서로 다른 세 가지 분류 알고리즘 구현, 즉 *rxDForest*, *rxFastTrees* 및 *rxFastForest*가 평가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-249">Three different classification algorithm implementations were evaluated: *rxDForest*, *rxFastTrees*, and *rxFastForest*.</span></span> <span data-ttu-id="d49a6-250">이 세 가지 알고리즘은 모두 다중 스레딩과 병렬 처리를 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-250">All three algorithms take advantage of multi-threading and parallelism.</span></span> <span data-ttu-id="d49a6-251">그리고 Microsoft ML은 가능한 경우 다중 CPU 또는 GPU를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-251">And Microsoft ML will use multiple CPUs or GPUs if available.</span></span> <span data-ttu-id="d49a6-252">모델 평가 조건은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-252">The criteria for evaluating the models included:</span></span>

- <span data-ttu-id="d49a6-253">새 모델이 원래 모델보다 더 정확했습니까?</span><span class="sxs-lookup"><span data-stu-id="d49a6-253">Were the new models more accurate that the original model?</span></span>
- <span data-ttu-id="d49a6-254">프로덕션에서 실행되는 모델의 메모리 공간은 어떻게 됩니까?</span><span class="sxs-lookup"><span data-stu-id="d49a6-254">What was the memory footprint of the models running in production?</span></span> <span data-ttu-id="d49a6-255">정확성을 손상시키지 않으면서 운영 환경에서 여러 모델의 동시 실행을 실시간에 가까운 예측 응답으로 지원할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="d49a6-255">Without compromising accuracy, could the operational environment support simultaneous execution of many models with near real-time prediction response?</span></span>
- <span data-ttu-id="d49a6-256">알고리즘에서 불균형 데이터 세트를 얼마나 잘 처리했습니까?</span><span class="sxs-lookup"><span data-stu-id="d49a6-256">How well did the algorithm handle the unbalanced data set?</span></span> <span data-ttu-id="d49a6-257">가상 데이터를 생성하여 불균형을 미리 처리해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="d49a6-257">Would the imbalance need to be pre-treated by generating synthetic data?</span></span>

<span data-ttu-id="d49a6-258">아래 표에는 결과가 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-258">The table below summarizes the findings:</span></span>

| <span data-ttu-id="d49a6-259">알고리즘</span><span class="sxs-lookup"><span data-stu-id="d49a6-259">Algorithm</span></span> | <span data-ttu-id="d49a6-260">설명</span><span class="sxs-lookup"><span data-stu-id="d49a6-260">Description</span></span> | <span data-ttu-id="d49a6-261">결과</span><span class="sxs-lookup"><span data-stu-id="d49a6-261">Findings</span></span> | <span data-ttu-id="d49a6-262">메모</span><span class="sxs-lookup"><span data-stu-id="d49a6-262">Notes</span></span> |
| :--------- | :------------ | :--------- | :--------------- |
| [<span data-ttu-id="d49a6-263">rxFastTrees</span><span class="sxs-lookup"><span data-stu-id="d49a6-263">rxFastTrees</span></span>](https://docs.microsoft.com/machine-learning-server/r-reference/microsoftml/rxfasttrees) | <span data-ttu-id="d49a6-264">FastRank의 다중 스레드 버전을 구현하는 향상된 의사 결정 트리의 병렬 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-264">Parallel implementation of boosted decision tree that implements multi-threaded version of FastRank.</span></span> | <span data-ttu-id="d49a6-265">성능이 정확하고 가장 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-265">Accurate, fastest performance.</span></span> | <span data-ttu-id="d49a6-266">불균형 데이터에 대한 특별한 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-266">No special features for unbalanced data.</span></span> <span data-ttu-id="d49a6-267">사전 처리된 데이터를 입력으로 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-267">Pre-treated data needed to be provided as input</span></span> |
| [<span data-ttu-id="d49a6-268">rxFastForest</span><span class="sxs-lookup"><span data-stu-id="d49a6-268">rxFastForest</span></span>](https://docs.microsoft.com/machine-learning-server/r-reference/microsoftml/rxfastforest) | <span data-ttu-id="d49a6-269">임의 포리스트의 병렬 구현이며, rxFastTrees를 사용하여 의사 결정 트리의 앙상블 학습자를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-269">Parallel implementation of random forest and uses rxFastTrees to build an ensemble learner of decision trees.</span></span> | <span data-ttu-id="d49a6-270">사전 처리된 데이터를 사용하여 원래 모델보다 더 정확합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-270">Better accuracy than original with pre-treated data.</span></span> <span data-ttu-id="d49a6-271">메모리 집약도가 낮고, rxDForest보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-271">Less memory intensive, faster than rxDForest</span></span> |<span data-ttu-id="d49a6-272">불균형 데이터에 대한 특별한 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-272">No special features for unbalanced data.</span></span> <span data-ttu-id="d49a6-273">사전 처리된 데이터를 입력으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-273">Pre-treated data provided as input.</span></span> |
| [<span data-ttu-id="d49a6-274">rxDForest</span><span class="sxs-lookup"><span data-stu-id="d49a6-274">rxDForest</span></span>](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rxdforest) | <span data-ttu-id="d49a6-275">랜덤 포리스트의 병렬 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-275">Parallel implementation of random forest.</span></span> <span data-ttu-id="d49a6-276">RevoScaleR에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-276">Included in RevoScaleR.</span></span> <span data-ttu-id="d49a6-277">함수 호출 내에서 불균형 데이터를 처리할 수 있습니다(누락된 데이터 제거, 조건 데이터 제거, 샘플 계층화 처리).</span><span class="sxs-lookup"><span data-stu-id="d49a6-277">Can deal with unbalanced data (removes missing data, conditions data, handles stratification of samples) all within the function call.</span></span> | <span data-ttu-id="d49a6-278">원래 모델보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-278">Faster than original model.</span></span> <span data-ttu-id="d49a6-279">정확도는 원래 모델과 동일하거나 더 높습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-279">Same or better accuracy than original model.</span></span> <span data-ttu-id="d49a6-280">다시 샘플링하고 합성하는 다양한 기술을 사용하여 불균형 데이터 세트를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-280">Handles unbalanced data set using a variety of techniques for re-sampling and synthesizing.</span></span> <span data-ttu-id="d49a6-281">메모리 공간이 가장 큽니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-281">Largest memory footprint.</span></span>  | <span data-ttu-id="d49a6-282">조건부 데이터가 함수 내에 포함되어 있으므로 메모리 공간이 가장 큽니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-282">Largest memory footprint because it includes the conditioned data within the function.</span></span>   <span data-ttu-id="d49a6-283">데이터 처리는 양호했지만, 데이터 소유자가 제공한 사용자 지정 변환만큼 양호하지는 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-283">Treatment of the data was good but not as good as the customized transformations provided by the data owner.</span></span> |

<span data-ttu-id="d49a6-284">결과적으로, 고객은 *rxFastForest* 알고리즘을 선택했고, [vtreat](https://cran.r-project.org/web/packages/vtreat/index.html) 라이브러리를 사용하고 과소 표시된 구독자에 대한 데이터를 합성하여 생성하는 데이터 전처리 단계를 추가하여 불균형 데이터를 처리하도록 결정했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-284">In the end, the customer selected the *rxFastForest* algorithm and decided to treat the unbalanced data by using the [vtreat](https://cran.r-project.org/web/packages/vtreat/index.html) library and adding a customized data pre-processing step to synthetically generate data for the under-represented subscribers.</span></span>

## <a name="model-deployment--web-services"></a><span data-ttu-id="d49a6-285">모델 배포 및 웹 서비스</span><span class="sxs-lookup"><span data-stu-id="d49a6-285">Model Deployment & Web Services</span></span>

<span data-ttu-id="d49a6-286">운영 VM에 배포할 모델을 게시하는 작업은 간단하며, [mrsdeploy를 사용하여 웹 서비스로 R 모델 배포](https://docs.microsoft.com/machine-learning-server/operationalize/quickstart-publish-r-web-service) 빠른 시작 설명서에 문서화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-286">Publishing a model for deployment to the operations VM is straight-forward and documented in this QuickStart documentation [Deploy an R Model as a web service with mrsdeploy](https://docs.microsoft.com/machine-learning-server/operationalize/quickstart-publish-r-web-service).</span></span>
<span data-ttu-id="d49a6-287">이 시나리오에서는 개발 VM에서 모델을 만든 후에 다음 단계를 사용하여 운영 VM에 게시했습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-287">In our scenario, once the models were created on the development VM, they were published on the operations VM using these steps:</span></span>

1. <span data-ttu-id="d49a6-288">인증을 위해 mrsdeploy 패키지에서 사용할 수 있는 두 가지 함수, 즉 로컬 관리자 이름과 암호를 사용하는 remoteLogin() 및 Azure Active Directory를 사용하는 remoteLoginAAD() 중 하나를 사용하여 개발자 VM에서 운영 VM으로의 원격 로그인을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-288">Establish a remote login from the developer VM to the operations VM using one of two functions available in the mrsdeploy package for authentication; remoteLogin() using a local admin name and password, or remoteLoginAAD() using Azure Active Directory.</span></span> <span data-ttu-id="d49a6-289">두 옵션은 앞에서 언급한 참고 자료에서 설명하고 있습니다. mrsdeploy를 사용하여 Machine Learning Server 또는 R Server에 로그인하고 원격 세션을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-289">Both options are described in this reference Log in to Machine Learning Server or R Server with mrsdeploy and open a remote session.</span></span>  
2. <span data-ttu-id="d49a6-290">모델이 학습되면 mrsdeploy 패키지의 publishService 또는 updateService 함수를 사용하여 해당 모델을 운영 VM에 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-290">Once a model is trained, publish it to the operations VM using the publishService or updateService functions in the mrsdeploy package.</span></span> <span data-ttu-id="d49a6-291">이 프로젝트에서 여러 가지 배포 방법을 사용했으며, 방법에 따라 새 모델이 게시되거나 기존 모델이 업데이트되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-291">For this project, we used multiple deployment approaches, and—depending on the approach—either a new model was published, or an existing model was updated.</span></span> <span data-ttu-id="d49a6-292">두 경우를 모두 처리하도록 구현된 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-292">The following code was implemented to handle both cases:</span></span>

````r
# If the service does not exist, publish it and if it does exist, update it.  
# No service by this name so publish one
 api <- publishService(serviceName, code =sc_predict, model = model,  
      inputs = list(prop_data="data.frame"),  
      outputs = list(answer = "numeric"), v = "v1.0.0" )
 print("=========== Model Created =============")
} else {
# A service by this name already exists, update it  
 api <- updateService(serviceName, model = model,
     inputs = list(prop_data="data.frame"), v = "v1.0.0" )
 print("=========== Model Updated =============")
}
 ````

모델이 배포되면 직렬화되어 운영 서버에 저장되며, *표준* 또는 *실시간* 모드에서 웹 서비스를 통해 사용될 수 있습니다. 웹 서비스를 표준 모드로 호출할 때마다 R 및 필요한 모든 라이브러리는 각 호출에 따라 로드 및 언로드됩니다. 이와 반대로 *실시간* 모드에서는 R 및 라이브러리가 한 번만 로드되고 후속 웹 서비스 호출에서 다시 사용됩니다. 웹 서비스 호출로 인한 대부분의 오버헤드는 R과 라이브러리를 로드하는 것이므로, 실시간 모드는 모델 점수 매기기에 훨씬 짧은 대기 시간을 제공하며 응답 시간은 10밀리초 미만일 수 있습니다. 표준 및 실시간 옵션 모두에 대해서는 [여기](https://docs.microsoft.com/machine-learning-server/operationalize/concept-what-are-web-services)의 설명서 및 참조 예제를 참조하세요. 실시간 모드는 단일 예측에 매우 적합하지만, 점수 매기기에 대한 입력 데이터 프레임을 전달할 수도 있습니다. <span data-ttu-id="d49a6-299">이와 관련하여 [mrsdeploy를 사용한 일괄 처리를 통한 비동기 웹 서비스 사용](https://docs.microsoft.com/machine-learning-server/operationalize/how-to-consume-web-service-asynchronously-batch) 참고 자료에서 설명하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-299">That is described in this reference: [Asynchronous web service consumption via batch processing with mrsdeploy](https://docs.microsoft.com/machine-learning-server/operationalize/how-to-consume-web-service-asynchronously-batch).</span></span>

## <a name="conclusion"></a><span data-ttu-id="d49a6-300">결론</span><span class="sxs-lookup"><span data-stu-id="d49a6-300">Conclusion</span></span>

<span data-ttu-id="d49a6-301">Microsoft Machine Learning Server에 기본적으로 제공된 MicrosoftML 및 RevoScaleR 라이브러리의 병렬 처리를 활용하여 수백 명의 구독자에 대한 개별 분류 모델의 개발, 배포 및 점수 매기기가 가속화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-301">Leveraging the parallelism of the MicrosoftML and RevoScaleR libraries built into Microsoft Machine Learning Server accelerated development, deployment, and scoring of individual classification models for hundreds of subscribers.</span></span> <span data-ttu-id="d49a6-302">모델 정확도가 향상되었고, 기존의 R 코드베이스를 최소한으로 변경하여 학습 및 재학습 시간이 단축되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-302">Model accuracy improved, and training and re-training times were compressed—all with minimal changes to the existing R code base.</span></span>
<span data-ttu-id="d49a6-303">모델 파이프라인을 지원하고 기술 구성 요소가 엔드투엔드에 올바르게 구성되도록 인프라를 구현하는 것은 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-303">Implementing the infrastructure to support a model pipeline and getting the technology components configured correctly end-to-end can be complex.</span></span> <span data-ttu-id="d49a6-304">사용자 고유의 방법을 시작하기 위한 몇 가지 참고 자료는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d49a6-304">Here are some references to get your started with your own approach:</span></span>

- [<span data-ttu-id="d49a6-305">Machine Learning Server 설명서</span><span class="sxs-lookup"><span data-stu-id="d49a6-305">Machine Learning Server Documentation</span></span>](https://docs.microsoft.com/machine-learning-server/)
- [<span data-ttu-id="d49a6-306">Machine Learning Server용 R 자습서</span><span class="sxs-lookup"><span data-stu-id="d49a6-306">R Tutorials for Machine Learning Server</span></span>](https://docs.microsoft.com/advanced-analytics/tutorials/sql-server-r-tutorials?view=sql-server-2017)
- [<span data-ttu-id="d49a6-307">Machine Learning Server용 R 샘플</span><span class="sxs-lookup"><span data-stu-id="d49a6-307">R Samples for Machine Learning Server</span></span>](https://docs.microsoft.com/machine-learning-server/r/r-samples)
- [<span data-ttu-id="d49a6-308">R 함수 라이브러리 참조</span><span class="sxs-lookup"><span data-stu-id="d49a6-308">R Function Library Reference</span></span>](https://docs.microsoft.com/machine-learning-server/r-reference/introducing-r-server-r-package-reference)

## <a name="references"></a><span data-ttu-id="d49a6-309">참조</span><span class="sxs-lookup"><span data-stu-id="d49a6-309">References</span></span>

<span data-ttu-id="d49a6-310">소매 비즈니스를 위한 다른 예측 솔루션을 구축하는 데 관심이 있는 경우 [Azure AI Gallery](https://gallery.azure.ai/)의 [소매 섹션](https://gallery.azure.ai/industries/retail)을 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="d49a6-310">If you are interested in building other predictive solutions for your retail business, visit the [retail section](https://gallery.azure.ai/industries/retail) of the Azure [AI Gallery](https://gallery.azure.ai/).</span></span>  